---
title: "Probability and Statistics"
subtitle: "The Evolution of Computer Processors: A statistic on Common Properties"
author: "Chau Dang Minh - 2013748 <br> Provide your name guys"
output: 
  # pdf_document: default
  html_document: default
---

# Libraries

```{r message=FALSE}
# Libraries and options
library(dplyr)
library(here)
library(knitr)
library(kableExtra)
library(ggplot2)
library(ggpubr)
library(car)

options(repr.plot.width = 15, repr.plot.height =8)

# Self-defined functions
source("utils.R")

# Working directory
setwd(here())
```


# Dataset Preprocessing

## Data reading and display

```{r}
CPUs_raw <- read.csv("dataset/Intel_CPUs.csv")
kable(head(CPUs_raw), format = "html") %>%
  kable_styling()

GPUs_raw <- read.csv("dataset/All_GPUs.csv")
kable(head(GPUs_raw), format = "html") %>%
  kable_styling()
```

## Feature inspection

```{r}
cpu_columns <- colnames(CPUs_raw)
gpu_columns <- colnames(GPUs_raw)
intersect(cpu_columns, gpu_columns)
```
It can be seen that there are no common columns between the dataframes. However, some columns may indicate the same feature, which needed to be handled manually.

## Data cleaning

We take a look at invalid values in the dataframes

```{r}
inspect_invalid(CPUs_raw)
```

The dataframes to inference must not have any invalid values. Here, we select features where invalid percentage precedes our threshold $\texttt{invalid_thres}$.

```{r}
CPUs_selected <- select_data(CPUs_raw, invalid_thres=0.5)

kable(head(CPUs_selected), format = "html") %>%
  kable_styling()
```


## Data Precomputations
1. Extract $\texttt{Release_Date}$ string to number pair $\texttt{Release_Year}$ and $\texttt{Release_Quarter}$.
2. Convert $\texttt{Recommended_Customer_Price}$ to number. If a range is presented, take the average.

```{r}
month_to_quarter <- function(month) {
  quarter <- switch(month,
    "Jan" = "1",
    "Feb" = "1",
    "Mar" = "1",
    "Apr" = "2",
    "May" = "2",
    "Jun" = "2",
    "Jul" = "3",
    "Aug" = "3",
    "Sep" = "3",
    "Oct" = "4",
    "Nov" = "4",
    "Dec" = "4",
    "Unknown")
    return(quarter)
}

recommended_price <- function(price_range) {
  if(grepl('-', price_range)) {
    range <- strsplit(price_range, " - ")[[1]]
    return((as.double(range[1]) + as.double(range[2])) / 2)
  }
  return (price_range)
}

names(CPUs_selected)[names(CPUs_selected) == "Launch_Date"] <- "Release_Date"

CPUs_processed <- CPUs_selected

CPUs_processed$Release_Year <- 
  as.integer(sub("Q[1-4]'(\\d+)", "\\1",
    gsub("\\s+", "", CPUs_selected$Release_Date)))
CPUs_processed$Release_Year <- 
  ifelse(CPUs_processed$Release_Year > 60, 
         1900 + CPUs_processed$Release_Year, 
         2000 + CPUs_processed$Release_Year)

CPUs_processed$Release_Quarter <- 
  as.integer(sub("Q([1-4])'.*", "\\1",
    gsub("\\s+", "", CPUs_selected$Release_Date)))

CPUs_processed <- CPUs_processed %>%
  mutate(
    Recommended_Customer_Price = as.double(sapply(gsub("[\\$,]", "", Recommended_Customer_Price), recommended_price))
  )

CPUs_processed$Lithography <- 
  as.integer(gsub("nm", "", 
                 CPUs_processed$Lithography))

kable(head(CPUs_processed), format = "html") %>%
  kable_styling()
```

# Descriptive Statistics

```{r}
litho_year <- CPUs_processed %>% 
  group_by(Release_Year) %>%
  summarize(mean_litho = mean(Lithography),
            median_litho = median(Lithography),
    .groups = "drop"
  )

ggplot(litho_year, aes(x = Release_Year)) +
  geom_line(aes(y = mean_litho, color = "Mean")) +
  geom_line(aes(y = median_litho, color = "Median")) +
  scale_color_manual(values = c("Mean" = "blue", "Median" = "red")) +
  labs(x = "Year", y = "Lithography", title = "Mean and Median Lithography by Year") +
  scale_x_continuous(breaks = seq(min(litho_year$Release_Year), max(litho_year$Release_Year),
  by = 1)) +
  theme_minimal()
```


# Inferential Statistics

## Two-way ANOVA 


```{r}

shapiro.test(CPUs_processed$nb_of_Cores)

ggqqplot(CPUs_processed$nb_of_Cores)

leveneTest(nb_of_Cores~Product_Collection*Vertical_Segment, data = CPUs_processed)


new_data <- CPUs_processed[CPUs_processed$Product_Collection %in% 
                                          c("Core", "Legacy") & 
                                          CPUs_processed$Vertical_Segment %in% 
                                          c("Desktop", "Embedded", "Mobile"),]

Product_Collection <- as.factor(new_data$Product_Collection)
Vertical_Segment <- as.factor(new_data$Vertical_Segment)
nb_of_Cores <- new_data$nb_of_Cores

av <- aov(nb_of_Cores ~ Product_Collection*Vertical_Segment, data = new_data)
summary(av)
```

## Linear Regression

